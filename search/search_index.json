{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Trubar A tool for translation and localization of Python programs via modification of source files. It replaces the original strings either with translations to produce a sources in a different language, or with lookups into table of translations. Trubar supports f-strings and does not require any changes to the original source code, such as marking strings for translation. See Getting Started for a simple introduction. Installation Install trubar using pip . pip install trubar","title":"Home"},{"location":"#trubar","text":"A tool for translation and localization of Python programs via modification of source files. It replaces the original strings either with translations to produce a sources in a different language, or with lookups into table of translations. Trubar supports f-strings and does not require any changes to the original source code, such as marking strings for translation. See Getting Started for a simple introduction.","title":"Trubar"},{"location":"#installation","text":"Install trubar using pip . pip install trubar","title":"Installation"},{"location":"command-line/","text":"Command line actions and their arguments Trubar is invoked by trubar <common-arguments> <action> <arguments> Common arguments are -h Prints help and exits. --conf <conf-file> Specifies the configuration file . If not given, Trubar searches for .trubarconfig.yaml and trubar-config.yaml in current directory, directory with messages, and in source directory (for collect and translate ). Action must be one of the following: collect: collects strings from the specified source tree, translate: copies the source tree and replaces strings with their translations, missing: prepares a file that contains untranslated messages from another message file (i.e., those with null translations), merge: inserts translations from one message file into another, template: uses translations into one language to prepare a template for another, stat: reports on the number of type of translations. Collect trubar collect [-h] [-p pattern] [-r removed-translations] [-q] [-n] -s source-dir messages Collects strings from the specified source tree, skipping files that don't end with .py or whose path includes tests/test_ . (The latter can be changed in configuration file .) Strings with no effect are ignored; this is aimed at docstrings, but will also skip any other unused strings. If the output file already exists, it is updated: new messages are merged into it, existing translations are kept, and obsolete messages are removed. The latter can be recorded using the option -r . messages The name of the file with messages (preferrably .jaml). If the file does not exist, it is created, otherwise it is updated with new messages and obsolete messages are removed. -s <path> , --source <path> Defines the root directory of the source tree. -p <pattern> , --pattern <pattern> Gives a pattern that the file path must include to be considered. The pattern is checked against the entire path; e.g. -p rm/pi would match the path farm/pigs.py: . -u , --newer Only consider source files that are newer than the message file (if it exists). -r <removed-translations> , --removed <removed-translations> The name of the file for messages that were present in the messages file but no longer needed. If omitted, removed translations, if any, are saved to file removed-from-<messages> , where message is the name of the message file. If the file already exists (<n>) is appended to the name. -n , --dry-run : Run, but do not change the output file. The file with removed messages is still written. -q , --quiet Supresses the output, except critical error messages. Translate trubar translate [-h] [-p pattern] [--static static-files-dir] [-q] [-v {0,1,2,3}] [-n] -s source-dir -d destination-dir messages Translates files with extension .py and writes them to destination directories, and copies all other files. Alternatively, -i can be given for translation in-place. Untranslated strings (marked null , false or true ) are kept as they are. The action overwrites any existing files. messages the name of the file with translated messages. -s <source-dir> , --source <source-dir> Root directory of the source tree. -d <dest-path> , --dest <dest-path> Destination directory. Either this option or -i is required. -i , --inplace In-place translation. Either this or -d is required. -p <pattern> , --pattern <pattern> A pattern that the file path must include to be considered. --static <static-files-path> Copies the file from the given path into destination tree; essentially cp -R <static-files-path> <dest-path>/<static-file-path> . This is used, for instance, for adding modules with target-language related features , like those for plural forms. This option can be given multiple times. If given, this argument overrides static-files from config file. -q , --quiet Supresses output messages, except for critical. Overrides option -v . -v <level> , --verbosity <level> Sets the verbosity level to 0 (critical messages, equivalent to -q ), 1 (report on files that are created or updated), 2 (also list files that have not changed) or 3 (report on all files, including those merely copied). This option is ignored in presence of -q . -n , --dry-run Run, but do not write anything. Merge trubar merge [-h] [-o output-file] [-u unused] [-p pattern] [-n] translations messages Merges translations into message file. translations (required) The \"source\" file with translations. messages (required) File with messages into which the translations from translations are merged. This file is modified unless another output file is given. -o <output-file> , --output <output-file> The output file name; if omitted, the file given as destination is changed. -u <unused> , --unused <unused> A name of the file for messages that no longer appear in the sources. -p <pattern> , --pattern <pattern> A pattern that the file path must include to be considered. -n , --dry-run Run, but do not write anything. Missing trubar missing [-h] [-p pattern] [-m all-messages] -o output-file messages Prepare a file with missing translations. A translation is missing if the translated message is null . Alternatively, the user can pass a file with all messages (option -m ), and the translation is missing if the translated file either does not include it or has a null translation. messages (required) The name of the file with messages. -o <output-file> , --output <output-file> (required) The name of the output file. -m <msg-file> , --all-messages <msg-file> If given, this file is considered to contain all messages. -p <pattern> , --pattern <pattern> If given, the output file will only contain messages from source files whose paths include the pattern. Template trubar template [-h] [-p pattern] -o output-file messages Create a template from existing translations. The output file will contain all strings that need attention. Strings that are \"translated\" to false are skipped, because they must not be translated. Strings that are \"translated\" to true are retained as they are. true indicates that they should probably be kept, but may also be translated if needed. If string is translated, the original is kept, but translation is replaced by null . Strings that are not translated ( null ) are kept. messages (required) Existing (preferrably complete) translations into some language. -o <output-file , --output <output-file> (required) Output file name. -p <pattern> , --pattern <pattern> If given, the output file will only contain messages from source files whose paths include the pattern. Stat trubar stat [-h] [-p pattern] messages Print statistics about messages in the given file. Here's an example output. messages File with messages. -p <pattern> , --pattern <pattern> If given, the count will include files whose paths include the pattern. Total messages: 11161 Translated: 3257 29.2% Kept unchanged: 313 2.8% Programmatic: 7065 63.3% Total completed: 10635 95.3% Untranslated: 526 4.7% Translated messages are those with actual translations, unchanged are translated as true and \"programmatic\" as false . \"Untranslated\" messages are those that are still marked as null and require translations.","title":"Command Line"},{"location":"command-line/#command-line-actions-and-their-arguments","text":"Trubar is invoked by trubar <common-arguments> <action> <arguments> Common arguments are -h Prints help and exits. --conf <conf-file> Specifies the configuration file . If not given, Trubar searches for .trubarconfig.yaml and trubar-config.yaml in current directory, directory with messages, and in source directory (for collect and translate ). Action must be one of the following: collect: collects strings from the specified source tree, translate: copies the source tree and replaces strings with their translations, missing: prepares a file that contains untranslated messages from another message file (i.e., those with null translations), merge: inserts translations from one message file into another, template: uses translations into one language to prepare a template for another, stat: reports on the number of type of translations.","title":"Command line actions and their arguments"},{"location":"command-line/#collect","text":"trubar collect [-h] [-p pattern] [-r removed-translations] [-q] [-n] -s source-dir messages Collects strings from the specified source tree, skipping files that don't end with .py or whose path includes tests/test_ . (The latter can be changed in configuration file .) Strings with no effect are ignored; this is aimed at docstrings, but will also skip any other unused strings. If the output file already exists, it is updated: new messages are merged into it, existing translations are kept, and obsolete messages are removed. The latter can be recorded using the option -r . messages The name of the file with messages (preferrably .jaml). If the file does not exist, it is created, otherwise it is updated with new messages and obsolete messages are removed. -s <path> , --source <path> Defines the root directory of the source tree. -p <pattern> , --pattern <pattern> Gives a pattern that the file path must include to be considered. The pattern is checked against the entire path; e.g. -p rm/pi would match the path farm/pigs.py: . -u , --newer Only consider source files that are newer than the message file (if it exists). -r <removed-translations> , --removed <removed-translations> The name of the file for messages that were present in the messages file but no longer needed. If omitted, removed translations, if any, are saved to file removed-from-<messages> , where message is the name of the message file. If the file already exists (<n>) is appended to the name. -n , --dry-run : Run, but do not change the output file. The file with removed messages is still written. -q , --quiet Supresses the output, except critical error messages.","title":"Collect"},{"location":"command-line/#translate","text":"trubar translate [-h] [-p pattern] [--static static-files-dir] [-q] [-v {0,1,2,3}] [-n] -s source-dir -d destination-dir messages Translates files with extension .py and writes them to destination directories, and copies all other files. Alternatively, -i can be given for translation in-place. Untranslated strings (marked null , false or true ) are kept as they are. The action overwrites any existing files. messages the name of the file with translated messages. -s <source-dir> , --source <source-dir> Root directory of the source tree. -d <dest-path> , --dest <dest-path> Destination directory. Either this option or -i is required. -i , --inplace In-place translation. Either this or -d is required. -p <pattern> , --pattern <pattern> A pattern that the file path must include to be considered. --static <static-files-path> Copies the file from the given path into destination tree; essentially cp -R <static-files-path> <dest-path>/<static-file-path> . This is used, for instance, for adding modules with target-language related features , like those for plural forms. This option can be given multiple times. If given, this argument overrides static-files from config file. -q , --quiet Supresses output messages, except for critical. Overrides option -v . -v <level> , --verbosity <level> Sets the verbosity level to 0 (critical messages, equivalent to -q ), 1 (report on files that are created or updated), 2 (also list files that have not changed) or 3 (report on all files, including those merely copied). This option is ignored in presence of -q . -n , --dry-run Run, but do not write anything.","title":"Translate"},{"location":"command-line/#merge","text":"trubar merge [-h] [-o output-file] [-u unused] [-p pattern] [-n] translations messages Merges translations into message file. translations (required) The \"source\" file with translations. messages (required) File with messages into which the translations from translations are merged. This file is modified unless another output file is given. -o <output-file> , --output <output-file> The output file name; if omitted, the file given as destination is changed. -u <unused> , --unused <unused> A name of the file for messages that no longer appear in the sources. -p <pattern> , --pattern <pattern> A pattern that the file path must include to be considered. -n , --dry-run Run, but do not write anything.","title":"Merge"},{"location":"command-line/#missing","text":"trubar missing [-h] [-p pattern] [-m all-messages] -o output-file messages Prepare a file with missing translations. A translation is missing if the translated message is null . Alternatively, the user can pass a file with all messages (option -m ), and the translation is missing if the translated file either does not include it or has a null translation. messages (required) The name of the file with messages. -o <output-file> , --output <output-file> (required) The name of the output file. -m <msg-file> , --all-messages <msg-file> If given, this file is considered to contain all messages. -p <pattern> , --pattern <pattern> If given, the output file will only contain messages from source files whose paths include the pattern.","title":"Missing"},{"location":"command-line/#template","text":"trubar template [-h] [-p pattern] -o output-file messages Create a template from existing translations. The output file will contain all strings that need attention. Strings that are \"translated\" to false are skipped, because they must not be translated. Strings that are \"translated\" to true are retained as they are. true indicates that they should probably be kept, but may also be translated if needed. If string is translated, the original is kept, but translation is replaced by null . Strings that are not translated ( null ) are kept. messages (required) Existing (preferrably complete) translations into some language. -o <output-file , --output <output-file> (required) Output file name. -p <pattern> , --pattern <pattern> If given, the output file will only contain messages from source files whose paths include the pattern.","title":"Template"},{"location":"command-line/#stat","text":"trubar stat [-h] [-p pattern] messages Print statistics about messages in the given file. Here's an example output. messages File with messages. -p <pattern> , --pattern <pattern> If given, the count will include files whose paths include the pattern. Total messages: 11161 Translated: 3257 29.2% Kept unchanged: 313 2.8% Programmatic: 7065 63.3% Total completed: 10635 95.3% Untranslated: 526 4.7% Translated messages are those with actual translations, unchanged are translated as true and \"programmatic\" as false . \"Untranslated\" messages are those that are still marked as null and require translations.","title":"Stat"},{"location":"configuration/","text":"Configuration file Trubar can be configured to replace messages with translations (single-language setup) or with lookups into tables of messages (multilingual setup). Configuration file is a yaml file with options-value pairs, for instance smart-quotes: false auto-prefix: true auto-import: \"from orangecanvas.localization.si import plsi, plsi_sz\" If configuration is not specified, Truber looks for .trubarconfig.yaml and trubar-config.yaml ,respectively, first in the current working directory and then in directory with message file, and then in source directory, as specified by -s argument (only for collect and translate ). The available options are smart-quotes (default: true) If set to false , strings in translated sources will have the same quotes as in the original source. Otherwise, if translation of a single-quoted includes a single quote, Trubar will output a double-quoted string and vice-versa. If translated message contains both types of quotes, they must be escaped with backslash. auto-prefix (default: true) If set, Trubar will turn strings into f-strings if translation contains braces and adding an f- prefix makes it a syntactically valid string, unless the original string already included braces, in which case this may had been a pattern for str.format . auto-import (default: none) A string that, if specified, is prepended to the beginning of each source file with translation. The use is described in the section on plural forms. static-files (default: none) A path of directory, or a list of paths. whose content is copied into translated sources. See the section on plural forms. This option is overridden by static argument in the command line, if given. exclude-pattern (default: \"tests/test_\" ) A regular expression for filtering out the files that should not be translated. The primary use for this is to exclude unit tests. encoding (default: \"utf-8\" ) Characted encoding for .jaml files, such as \"utf-8\" or \"cp-1252\" . Multilingual setup In a multilingual setup, the configuration file includes a section with languages. Each language is specified by a key, which is the language code, and a dictionary with options. Options include a name of the language, an international name, and any language-specific auto-import directives. For instance name (required) The native name of the language. Put into the table of messages at index 0. international-name (required) The international name of the language. Put into the table of messages at index 1. auto-import (default: none) Same as auto-import in single-language setup, but for the specific language. This text (if any) is added to other auto imports (if any). original (default: false) If set to true , the language is considered the original language of the source code. Example This is a multilingual setup for two languages that is used in Orange at the time of writing this document. languages: en: name: English original: true si: name: Sloven\u0161\u010dina international-name: Slovenian auto-import: from orangecanvas.localization.si import plsi, plsi_sz, z_besedo # pylint: disable=wrong-import-order auto-import: |2 from orangecanvas.localization import Translator # pylint: disable=wrong-import-order _tr = Translator(\"Orange\", \"biolab.si\", \"Orange\") del Translator encoding: \"utf-8\" For more on auto-imports, see the section on multilingual use .","title":"Configuration"},{"location":"configuration/#configuration-file","text":"Trubar can be configured to replace messages with translations (single-language setup) or with lookups into tables of messages (multilingual setup). Configuration file is a yaml file with options-value pairs, for instance smart-quotes: false auto-prefix: true auto-import: \"from orangecanvas.localization.si import plsi, plsi_sz\" If configuration is not specified, Truber looks for .trubarconfig.yaml and trubar-config.yaml ,respectively, first in the current working directory and then in directory with message file, and then in source directory, as specified by -s argument (only for collect and translate ). The available options are smart-quotes (default: true) If set to false , strings in translated sources will have the same quotes as in the original source. Otherwise, if translation of a single-quoted includes a single quote, Trubar will output a double-quoted string and vice-versa. If translated message contains both types of quotes, they must be escaped with backslash. auto-prefix (default: true) If set, Trubar will turn strings into f-strings if translation contains braces and adding an f- prefix makes it a syntactically valid string, unless the original string already included braces, in which case this may had been a pattern for str.format . auto-import (default: none) A string that, if specified, is prepended to the beginning of each source file with translation. The use is described in the section on plural forms. static-files (default: none) A path of directory, or a list of paths. whose content is copied into translated sources. See the section on plural forms. This option is overridden by static argument in the command line, if given. exclude-pattern (default: \"tests/test_\" ) A regular expression for filtering out the files that should not be translated. The primary use for this is to exclude unit tests. encoding (default: \"utf-8\" ) Characted encoding for .jaml files, such as \"utf-8\" or \"cp-1252\" .","title":"Configuration file"},{"location":"configuration/#multilingual-setup","text":"In a multilingual setup, the configuration file includes a section with languages. Each language is specified by a key, which is the language code, and a dictionary with options. Options include a name of the language, an international name, and any language-specific auto-import directives. For instance name (required) The native name of the language. Put into the table of messages at index 0. international-name (required) The international name of the language. Put into the table of messages at index 1. auto-import (default: none) Same as auto-import in single-language setup, but for the specific language. This text (if any) is added to other auto imports (if any). original (default: false) If set to true , the language is considered the original language of the source code.","title":"Multilingual setup"},{"location":"configuration/#example","text":"This is a multilingual setup for two languages that is used in Orange at the time of writing this document. languages: en: name: English original: true si: name: Sloven\u0161\u010dina international-name: Slovenian auto-import: from orangecanvas.localization.si import plsi, plsi_sz, z_besedo # pylint: disable=wrong-import-order auto-import: |2 from orangecanvas.localization import Translator # pylint: disable=wrong-import-order _tr = Translator(\"Orange\", \"biolab.si\", \"Orange\") del Translator encoding: \"utf-8\" For more on auto-imports, see the section on multilingual use .","title":"Example"},{"location":"getting-started/","text":"Getting Started Imagine a Python project named sample with the following typical structure. sample farm __init__.py pigs.py __main__.py setup.py README LICENSE File sample/farm/pigs.py contains class PigManager: def __init__(self, n): if not 5 <= n <= 20: raise ValueError( f\"Wrong number: number of pigs should be between 5 and 20, not {n}.\") self.n = n def walk(self): print(f\"{self.n} little pigs went for a walk\") and sample/__main__.py contains from farm.pigs import PigManager def main(): ns = input(\"Enter a number between 5 and 20: \") try: n = int(ns) except ValueError: print(f\"'{n}' is not a number\") else: farm = PigManager(n) farm.walk() if __name__ == \"__main__\": main() and sample/farm/__init__.py is empty. Note that, unlike in the gettext framework, messages are not \"marked\" for translation by being passed through a call to a translation function like _ , tr or gettext . Collecting messages To collect all strings in the project, use collect . trubar collect -s code/sample sample.jaml The argument -s gives the root directory. This will usually not be the root of the project, which only contains \"administrative\" files like setup.py, but the directory with actual sources that need translation. The found strings are written into the output file, in our example sample.jaml . __main__.py: def `main`: 'Enter a number between 5 and 20: ': null \"'{n}' is not a number.\": null __main__: null farm/pigs.py: class `PigManager`: def `__init__`: 'Wrong number: number of pigs should be between 5 and 20, not {n}.': null def `walk`: {self.n} little pigs went for a walk: null See the section about Message files for details about the file format. Translating messages The next step is to edit the .jaml file: null 's need to be replaced by translations or marked in another way. Here's a Slovenian translation. __main__.py: def `main`: 'Enter a number between 5 and 20: ': 'Vnesite \u0161tevilo med 5 in 20: ' \"'{n}' is not a number.\": '{n}' ni \u0161tevilo. __main__: false farm/pigs.py: class `PigManager`: def `__init__`: # I translated this, but I'm not sure it's needed. 'Wrong number: {n} is not between 5 and 20.': Napa\u010dno \u0161tevilo: {n} ni med 5 in 20. def `walk`: {self.n} little pigs went for a walk: {self.n} pra\u0161i\u010dkov se je \u0161lo sprehajat. We translated __main__ as false , which indicates that this string must not be translated. Other options are explained later . Applying translations In the simplest scenario, we want to produce new sources in which the original strings are replaced by translations. We first prepare a copy of the entire project because Trubar will only copy the files within the scanned directories. Suppose that ../project_copy contains such a copy. Now run translate . trubar translate -s code/sample -d ../project_copy/code/sample sample.jaml In most cases, we want to also add a configuration file .","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"Imagine a Python project named sample with the following typical structure. sample farm __init__.py pigs.py __main__.py setup.py README LICENSE File sample/farm/pigs.py contains class PigManager: def __init__(self, n): if not 5 <= n <= 20: raise ValueError( f\"Wrong number: number of pigs should be between 5 and 20, not {n}.\") self.n = n def walk(self): print(f\"{self.n} little pigs went for a walk\") and sample/__main__.py contains from farm.pigs import PigManager def main(): ns = input(\"Enter a number between 5 and 20: \") try: n = int(ns) except ValueError: print(f\"'{n}' is not a number\") else: farm = PigManager(n) farm.walk() if __name__ == \"__main__\": main() and sample/farm/__init__.py is empty. Note that, unlike in the gettext framework, messages are not \"marked\" for translation by being passed through a call to a translation function like _ , tr or gettext .","title":"Getting Started"},{"location":"getting-started/#collecting-messages","text":"To collect all strings in the project, use collect . trubar collect -s code/sample sample.jaml The argument -s gives the root directory. This will usually not be the root of the project, which only contains \"administrative\" files like setup.py, but the directory with actual sources that need translation. The found strings are written into the output file, in our example sample.jaml . __main__.py: def `main`: 'Enter a number between 5 and 20: ': null \"'{n}' is not a number.\": null __main__: null farm/pigs.py: class `PigManager`: def `__init__`: 'Wrong number: number of pigs should be between 5 and 20, not {n}.': null def `walk`: {self.n} little pigs went for a walk: null See the section about Message files for details about the file format.","title":"Collecting messages"},{"location":"getting-started/#translating-messages","text":"The next step is to edit the .jaml file: null 's need to be replaced by translations or marked in another way. Here's a Slovenian translation. __main__.py: def `main`: 'Enter a number between 5 and 20: ': 'Vnesite \u0161tevilo med 5 in 20: ' \"'{n}' is not a number.\": '{n}' ni \u0161tevilo. __main__: false farm/pigs.py: class `PigManager`: def `__init__`: # I translated this, but I'm not sure it's needed. 'Wrong number: {n} is not between 5 and 20.': Napa\u010dno \u0161tevilo: {n} ni med 5 in 20. def `walk`: {self.n} little pigs went for a walk: {self.n} pra\u0161i\u010dkov se je \u0161lo sprehajat. We translated __main__ as false , which indicates that this string must not be translated. Other options are explained later .","title":"Translating messages"},{"location":"getting-started/#applying-translations","text":"In the simplest scenario, we want to produce new sources in which the original strings are replaced by translations. We first prepare a copy of the entire project because Trubar will only copy the files within the scanned directories. Suppose that ../project_copy contains such a copy. Now run translate . trubar translate -s code/sample -d ../project_copy/code/sample sample.jaml In most cases, we want to also add a configuration file .","title":"Applying translations"},{"location":"localization/","text":"F-strings and localization issues F-strings offer a powerful support for translation into language with complex grammar. Automated f-strings Trubar sometimes turn strings into f-string in translated files. If the original source contains an f-string, Trubar will keep the f-prefix in translated source even if the translation does not contain any parts to interpolate. Superfluous f-prefixes do not hurt. If the original string is not an f-string but the translation contains braces and prefixing this string with f- makes it a syntactically valid f-string, Trubar will add an f-prefix unless: the original string already included braces (so this may be a pattern for str.format ) or this behaviour is explicitly disabled in configuration by setting auto-prefix: false . Plural forms Trubar does not itself offer any specific functionality for plural forms. There is however a neat way of doing it, in particular if the original source is written in a translation-friendly way. The number of pigs in the getting started example is between 5 and 20, which requires a plural in any language with which the author of this text is sufficiently familiar. But now suppose that the number of pigs can be an arbitrary non-negative number. How do we translate \"{self.n} little pigs went for a walk\" ? Plural forms in English The simplest way to support English plural in a large project would be to have a module, say in file utils.localization.__init__.py , with a function def pl(n: int, forms: str) -> str: plural = int(n != 1) if \"|\" in forms: return forms.split(\"|\")[plural] if forms[-1] in \"yY\" and forms[-2] not in \"aeiouAEIOU\": word = [forms, forms[:-1] + \"ies\"][plural] else: word = forms + \"s\" * plural if forms.isupper(): word = word.upper() return word With this, the above string should be written as \"{self.n} little {pl(self.n, 'pig')} went for a walk\" The function take care of regular-ish plural forms, including \"piggy\" ( \"piggies\" ) as well as \"monkey\" ( \"monkeys\" ). If the plural is irregular, it requires both forms, separated by | , e.g. pl(n, \"leaf|leaves\") . Plural forms for other languages For other languages, one can write a similar module. If the project already includes utils/localization/__init__.py , an appropriate place for a Slovenian-language functions would be utils/localization/si.py . The function can be arbitrarily complex. This one takes care of Slovenian nouns, which have four plural forms in nominative and three in other cases, and also offers some automation for nominative case of some regular nouns. def plsi(n: int, forms: str) -> str: n = abs(n) % 100 if n == 4: n = 3 elif n == 0 or n >= 5: n = 4 n -= 1 if \"|\" in forms: forms = forms.split(\"|\") if n == 3 and len(forms) == 3: n -= 1 return forms[n] if forms[-1] == \"a\": return forms[:-1] + (\"a\", \"i\", \"e\", \"\")[n] else: return forms + (\"\", \"a\", \"i\", \"ov\")[n] The translation of {self.n} {pl(self.n, 'pig')} into Slovenian is then {self.n} {plsi(self.n, 'pujsek|pujska|pujski|pujskov')} while the entire sentence {self.n} little pigs went for a walk requires changing most of the sentence `\"{self.n} {plsi(self.n, 'pujsek se je \u0161el|pujska sta se \u0161la|pujski so se \u0161li|pujskov se je \u0161lo')} sprehajat.\"` Note that this works even if the original message does not contain any plural forms, for instance because the way it is phrased original is independent of the number. The only condition is that the number, in our case self.n is easily accessible in the string. This is also the reason why Trubar automatically turns strings into f-strings when it detects braces with expressions. Other localization functions The language-specific module can contain other support functions. For instance, the Slovenian translation of the word \"with\" in a message \"With {self.n} {pl(self.n, 'pigs')}\" is either \"s\" or \"z\", depending on the first sound of the number. Therefore, the Slovenian module for localization includes a function plsi_sz(n) that returns the necessary preposition for the given. The translation of the above would thus be {plsi_sz(self.n)} {self.n} {pl(self.n, 'pujskom|pujskoma|pujski')} The same mechanism can be used for other language quirks. Importing localization functions The above examples requires importing the localization functions, such as plsi and plsi_sz . First, the translated sources must include the necessary module, which does not exist in the original source. To this end, we need to prepare a directory with static files. In our case, we can have a directory named, for instance si-local , containing si-local/utils/localization/__init__.py . When translating, we instruct Trubar to copy this into translated source tree by adding an option --static si-local to the translate action . Second, all translated source files must include the necessary import. We do this using a directive in configuration file : auto-import: \"from orangecanvas.localization.si import plsi, plsi_sz\" Trubar will prepend this line to the beginning of all files with any translations. Other forms of interpolation While Trubar works best with f-strings, other forms of interpolation in Python, % and format can sometimes be translated, provided the required data can be extracted. For instance, with \"%i little pigs\" % self.n , the translator would see the string part, %i little pigs and could translate it to \"{plsi(self.n, '%i pujsek|%i pujska|%i pujski|%i pujskov')}\" , that is, (s)he would replace the entire string with variations corresponding to different values of self.n . Persuading developpers to use f-strings is obviously a better alternative.","title":"Localization Issues"},{"location":"localization/#f-strings-and-localization-issues","text":"F-strings offer a powerful support for translation into language with complex grammar.","title":"F-strings and localization issues"},{"location":"localization/#automated-f-strings","text":"Trubar sometimes turn strings into f-string in translated files. If the original source contains an f-string, Trubar will keep the f-prefix in translated source even if the translation does not contain any parts to interpolate. Superfluous f-prefixes do not hurt. If the original string is not an f-string but the translation contains braces and prefixing this string with f- makes it a syntactically valid f-string, Trubar will add an f-prefix unless: the original string already included braces (so this may be a pattern for str.format ) or this behaviour is explicitly disabled in configuration by setting auto-prefix: false .","title":"Automated f-strings"},{"location":"localization/#plural-forms","text":"Trubar does not itself offer any specific functionality for plural forms. There is however a neat way of doing it, in particular if the original source is written in a translation-friendly way. The number of pigs in the getting started example is between 5 and 20, which requires a plural in any language with which the author of this text is sufficiently familiar. But now suppose that the number of pigs can be an arbitrary non-negative number. How do we translate \"{self.n} little pigs went for a walk\" ?","title":"Plural forms"},{"location":"localization/#plural-forms-in-english","text":"The simplest way to support English plural in a large project would be to have a module, say in file utils.localization.__init__.py , with a function def pl(n: int, forms: str) -> str: plural = int(n != 1) if \"|\" in forms: return forms.split(\"|\")[plural] if forms[-1] in \"yY\" and forms[-2] not in \"aeiouAEIOU\": word = [forms, forms[:-1] + \"ies\"][plural] else: word = forms + \"s\" * plural if forms.isupper(): word = word.upper() return word With this, the above string should be written as \"{self.n} little {pl(self.n, 'pig')} went for a walk\" The function take care of regular-ish plural forms, including \"piggy\" ( \"piggies\" ) as well as \"monkey\" ( \"monkeys\" ). If the plural is irregular, it requires both forms, separated by | , e.g. pl(n, \"leaf|leaves\") .","title":"Plural forms in English"},{"location":"localization/#plural-forms-for-other-languages","text":"For other languages, one can write a similar module. If the project already includes utils/localization/__init__.py , an appropriate place for a Slovenian-language functions would be utils/localization/si.py . The function can be arbitrarily complex. This one takes care of Slovenian nouns, which have four plural forms in nominative and three in other cases, and also offers some automation for nominative case of some regular nouns. def plsi(n: int, forms: str) -> str: n = abs(n) % 100 if n == 4: n = 3 elif n == 0 or n >= 5: n = 4 n -= 1 if \"|\" in forms: forms = forms.split(\"|\") if n == 3 and len(forms) == 3: n -= 1 return forms[n] if forms[-1] == \"a\": return forms[:-1] + (\"a\", \"i\", \"e\", \"\")[n] else: return forms + (\"\", \"a\", \"i\", \"ov\")[n] The translation of {self.n} {pl(self.n, 'pig')} into Slovenian is then {self.n} {plsi(self.n, 'pujsek|pujska|pujski|pujskov')} while the entire sentence {self.n} little pigs went for a walk requires changing most of the sentence `\"{self.n} {plsi(self.n, 'pujsek se je \u0161el|pujska sta se \u0161la|pujski so se \u0161li|pujskov se je \u0161lo')} sprehajat.\"` Note that this works even if the original message does not contain any plural forms, for instance because the way it is phrased original is independent of the number. The only condition is that the number, in our case self.n is easily accessible in the string. This is also the reason why Trubar automatically turns strings into f-strings when it detects braces with expressions.","title":"Plural forms for other languages"},{"location":"localization/#other-localization-functions","text":"The language-specific module can contain other support functions. For instance, the Slovenian translation of the word \"with\" in a message \"With {self.n} {pl(self.n, 'pigs')}\" is either \"s\" or \"z\", depending on the first sound of the number. Therefore, the Slovenian module for localization includes a function plsi_sz(n) that returns the necessary preposition for the given. The translation of the above would thus be {plsi_sz(self.n)} {self.n} {pl(self.n, 'pujskom|pujskoma|pujski')} The same mechanism can be used for other language quirks.","title":"Other localization functions"},{"location":"localization/#importing-localization-functions","text":"The above examples requires importing the localization functions, such as plsi and plsi_sz . First, the translated sources must include the necessary module, which does not exist in the original source. To this end, we need to prepare a directory with static files. In our case, we can have a directory named, for instance si-local , containing si-local/utils/localization/__init__.py . When translating, we instruct Trubar to copy this into translated source tree by adding an option --static si-local to the translate action . Second, all translated source files must include the necessary import. We do this using a directive in configuration file : auto-import: \"from orangecanvas.localization.si import plsi, plsi_sz\" Trubar will prepend this line to the beginning of all files with any translations.","title":"Importing localization functions"},{"location":"localization/#other-forms-of-interpolation","text":"While Trubar works best with f-strings, other forms of interpolation in Python, % and format can sometimes be translated, provided the required data can be extracted. For instance, with \"%i little pigs\" % self.n , the translator would see the string part, %i little pigs and could translate it to \"{plsi(self.n, '%i pujsek|%i pujska|%i pujski|%i pujskov')}\" , that is, (s)he would replace the entire string with variations corresponding to different values of self.n . Persuading developpers to use f-strings is obviously a better alternative.","title":"Other forms of interpolation"},{"location":"message-files/","text":"Message Files TL;DR: Look at the example from Getting Started. Read this page only if you run into problems and need details. Messages are stored in files with extension .jaml. Jaml is a simplified version of Yaml, limited to the functionality needed by Trubar. It does not support lists, flow collections, node anchors, different datatypes... This allows for simpler syntax, in particular less quotes. File Structure The first-level keys are file names, with their paths relative to the root passed in the -s option of collect and translate . (It is important to always use the same root for the project. Using -s code/ wouldn't only include the strings from setup.py , but also prepend sample to the names of all scanned files!) Lower levels have keys that start with def or class , and are followed by a subtree that starts in the next line, or represents a potentially translatable string, followed by the translation in that same line. There is no indication about whether a string is an f-string or not, neither does it show what kind of quotes are used in the source, because none of this matters. Trubar also reads and writes standard yaml (it distinguishes between yaml and jaml by file extensions), but we don't recommend using it because their formatting is more complex and any comments written by translator are lost at reading. Translations Translator can treat a string in approximately three ways. Provide a translation. Mark with false to indicate that it must not be translated. An example of such string is \"__main__\" or \"rb\" when calling function open . Mark it with true , if the strings that could be translated, but doesn't need it for this particular language or culture. A common example would be symbols like \"\u00a9\ufe0f\" . Leave it null until (s)he figures out what to do with it. The difference between true and false is important only when using this translation to prepare templates for translations into other languages. Comments Comments are useful to indicate questionable translations, brainstorm with other translators or oneself, and similar. Operations on message files, like extracting and merging, keep the comments at their respective places. A comment is always associated with some particular translation or entire function or class. It must be placed above it and conform to indendation. Comments cannot follow translations in the same line; a # symbol in translation is treated literally. Quotes Translation must be quoted if it begins or end with space, begins with a quote (single or double) it is (literally) \"false\" , \"true\" or \"null\" , (In addition, keys are quoted if they contain a colon followed by a space. But translator doesn't need to care because keys are provided by Trubar.) Single- and double-quoted strings are treated the same. The translation must begin and end with the same type of quote. The quotes used in message files are not related to the quotes used in source code. In the introductory example, all string in code use double quotes, while some strings in the message file are single-quoted and others double quoted, for convenience. A single-quoted string may contain double quotes and vice-versa; such quotes are treated literally. Any single (double) quotes within a single (double) quoted strings must be doubled, as in 'don''t forget to double the quotes.' . Colons Colons in translations have no special meaning. Consider the following line from the example. 'Wrong number: {n} is not between 5 and 20.': Napa\u010dno \u0161tevilo: {n} ni med 5 in 20. In standard yaml, the translation would need quotes because it includes a colon followed by space. In Jaml, this rule only applies to keys, which translator doesn't care about. Therefore: use colons at will. Multiline messages Strings can span over multiple lines. All whitespace in multiline strings is retained. JAML does not support any of the more complicated yaml syntax for multiline blocks.","title":"Message Files"},{"location":"message-files/#message-files","text":"TL;DR: Look at the example from Getting Started. Read this page only if you run into problems and need details. Messages are stored in files with extension .jaml. Jaml is a simplified version of Yaml, limited to the functionality needed by Trubar. It does not support lists, flow collections, node anchors, different datatypes... This allows for simpler syntax, in particular less quotes.","title":"Message Files"},{"location":"message-files/#file-structure","text":"The first-level keys are file names, with their paths relative to the root passed in the -s option of collect and translate . (It is important to always use the same root for the project. Using -s code/ wouldn't only include the strings from setup.py , but also prepend sample to the names of all scanned files!) Lower levels have keys that start with def or class , and are followed by a subtree that starts in the next line, or represents a potentially translatable string, followed by the translation in that same line. There is no indication about whether a string is an f-string or not, neither does it show what kind of quotes are used in the source, because none of this matters. Trubar also reads and writes standard yaml (it distinguishes between yaml and jaml by file extensions), but we don't recommend using it because their formatting is more complex and any comments written by translator are lost at reading.","title":"File Structure"},{"location":"message-files/#translations","text":"Translator can treat a string in approximately three ways. Provide a translation. Mark with false to indicate that it must not be translated. An example of such string is \"__main__\" or \"rb\" when calling function open . Mark it with true , if the strings that could be translated, but doesn't need it for this particular language or culture. A common example would be symbols like \"\u00a9\ufe0f\" . Leave it null until (s)he figures out what to do with it. The difference between true and false is important only when using this translation to prepare templates for translations into other languages.","title":"Translations"},{"location":"message-files/#comments","text":"Comments are useful to indicate questionable translations, brainstorm with other translators or oneself, and similar. Operations on message files, like extracting and merging, keep the comments at their respective places. A comment is always associated with some particular translation or entire function or class. It must be placed above it and conform to indendation. Comments cannot follow translations in the same line; a # symbol in translation is treated literally.","title":"Comments"},{"location":"message-files/#quotes","text":"Translation must be quoted if it begins or end with space, begins with a quote (single or double) it is (literally) \"false\" , \"true\" or \"null\" , (In addition, keys are quoted if they contain a colon followed by a space. But translator doesn't need to care because keys are provided by Trubar.) Single- and double-quoted strings are treated the same. The translation must begin and end with the same type of quote. The quotes used in message files are not related to the quotes used in source code. In the introductory example, all string in code use double quotes, while some strings in the message file are single-quoted and others double quoted, for convenience. A single-quoted string may contain double quotes and vice-versa; such quotes are treated literally. Any single (double) quotes within a single (double) quoted strings must be doubled, as in 'don''t forget to double the quotes.' .","title":"Quotes"},{"location":"message-files/#colons","text":"Colons in translations have no special meaning. Consider the following line from the example. 'Wrong number: {n} is not between 5 and 20.': Napa\u010dno \u0161tevilo: {n} ni med 5 in 20. In standard yaml, the translation would need quotes because it includes a colon followed by space. In Jaml, this rule only applies to keys, which translator doesn't care about. Therefore: use colons at will.","title":"Colons"},{"location":"message-files/#multiline-messages","text":"Strings can span over multiple lines. All whitespace in multiline strings is retained. JAML does not support any of the more complicated yaml syntax for multiline blocks.","title":"Multiline messages"},{"location":"multilingual/","text":"Setup for multilingual use Implementing a multilingual setup requires understanding of the code produced by Trubar. In single-language setup, strings are replaced by translated strings and f-strings pose no problem. Multilingual setup uses string tables for different languages. F-strings cannot be stored in such tables because they are syntactic elements and not Python objects. Instead, Trubar stores a string that contains an f-string. When the string needs to be used, it compiles and evaluates it in the local context. A slightly simplified example The following example is based on the Orange code base. A similar setup would be used in other projects. We first need to understand how Trubar modifies the sources in multilingual mode. A string \"Data Table\" is replaced by _tr.m[1651] . Neither the original string nor any of its translations are f-strings, so the string is replaced by lookup; the element at index 1651 in the English message table is \"Data Table\" and in the Slovenian table it is \"Tabela s podatki\" . We will tell more about where the _tr comes from and what it contains later. A string f\" ({perc:.1f} % missing data)\")) is replaced by _tr.e(_tr.c(1717) . The string at index 1717 in the English message table is \"f\\\" ({perc:.1f} % missing data)\\\"\" and the Slovenian translation is \"f\\\" ({perc:.1f} % manjkajo\u010dih podatkov)\\\"\" . Note that this is not a string but a string that contains and f-string. For this to work, the _tr must be an object with the following attributes: m is a list of strings, where the index corresponds to the index in the message table. e is a function that evaluates a string; in short, e is eval . c is a function that compiles a string at the given index; in short, c is compile . Trubar provides neither _tr nor its methods, and it doesn't import it because this is application specific. Orange's configuration for Trubar has an auto-import directive that inserts the following lines into each source file: from orangecanvas.localization import Translator # pylint: disable=wrong-import-order _tr = Translator() del Translator Other applications would import a similar class from another location and use different arguments for its constructor. The end result must be an object named _tr with the requires methods. The Translator class looks roughly like this: import json class Translator: def __init__(self): path = \"i18n/slovenian.jaml\" # Replace this with the actual path with open(path) as handle: # Note that the actual code is somewhat more complex; see below self.m = json.load(handle) e = eval def c(self, idx, *_): return compile(self.m[idx], '<string>', 'eval') In Orange, the Translator 's constructor requires Qt-related arguments, so the code from auto-import is actually _tr = Translator(\"Orange\", \"biolab.si\", \"Orange\") and the constructor uses these arguments to retrieve the current language from the settings and locates the appropriate file and reads it into self.m . The actual code The above description is simplified for clarity. Trubar doesn't replace \"Data Table\" by tr.m[1651] but by tr.m[1651, \"Data Table\"] ; similarly for f-strings. The second index, \"Data Table\" , is not used and is there only as a comment for any developers checking the translated sources. Translator doesn't load the message table with self.m = json.load(handle) but wraps the list into a class _list : self.m = json.load(handle) where _list is class _list(list): # Accept extra argument to allow for the original string def __getitem__(self, item): if isinstance(item, tuple): item = item[0] return super().__getitem__(item) Note again that Trubar doesn't provide this code, but your application would probably use similar code. Find the complete example at Orange Canvas Core's Github .","title":"Multilingual Use"},{"location":"multilingual/#setup-for-multilingual-use","text":"Implementing a multilingual setup requires understanding of the code produced by Trubar. In single-language setup, strings are replaced by translated strings and f-strings pose no problem. Multilingual setup uses string tables for different languages. F-strings cannot be stored in such tables because they are syntactic elements and not Python objects. Instead, Trubar stores a string that contains an f-string. When the string needs to be used, it compiles and evaluates it in the local context.","title":"Setup for multilingual use"},{"location":"multilingual/#a-slightly-simplified-example","text":"The following example is based on the Orange code base. A similar setup would be used in other projects. We first need to understand how Trubar modifies the sources in multilingual mode. A string \"Data Table\" is replaced by _tr.m[1651] . Neither the original string nor any of its translations are f-strings, so the string is replaced by lookup; the element at index 1651 in the English message table is \"Data Table\" and in the Slovenian table it is \"Tabela s podatki\" . We will tell more about where the _tr comes from and what it contains later. A string f\" ({perc:.1f} % missing data)\")) is replaced by _tr.e(_tr.c(1717) . The string at index 1717 in the English message table is \"f\\\" ({perc:.1f} % missing data)\\\"\" and the Slovenian translation is \"f\\\" ({perc:.1f} % manjkajo\u010dih podatkov)\\\"\" . Note that this is not a string but a string that contains and f-string. For this to work, the _tr must be an object with the following attributes: m is a list of strings, where the index corresponds to the index in the message table. e is a function that evaluates a string; in short, e is eval . c is a function that compiles a string at the given index; in short, c is compile . Trubar provides neither _tr nor its methods, and it doesn't import it because this is application specific. Orange's configuration for Trubar has an auto-import directive that inserts the following lines into each source file: from orangecanvas.localization import Translator # pylint: disable=wrong-import-order _tr = Translator() del Translator Other applications would import a similar class from another location and use different arguments for its constructor. The end result must be an object named _tr with the requires methods. The Translator class looks roughly like this: import json class Translator: def __init__(self): path = \"i18n/slovenian.jaml\" # Replace this with the actual path with open(path) as handle: # Note that the actual code is somewhat more complex; see below self.m = json.load(handle) e = eval def c(self, idx, *_): return compile(self.m[idx], '<string>', 'eval') In Orange, the Translator 's constructor requires Qt-related arguments, so the code from auto-import is actually _tr = Translator(\"Orange\", \"biolab.si\", \"Orange\") and the constructor uses these arguments to retrieve the current language from the settings and locates the appropriate file and reads it into self.m .","title":"A slightly simplified example"},{"location":"multilingual/#the-actual-code","text":"The above description is simplified for clarity. Trubar doesn't replace \"Data Table\" by tr.m[1651] but by tr.m[1651, \"Data Table\"] ; similarly for f-strings. The second index, \"Data Table\" , is not used and is there only as a comment for any developers checking the translated sources. Translator doesn't load the message table with self.m = json.load(handle) but wraps the list into a class _list : self.m = json.load(handle) where _list is class _list(list): # Accept extra argument to allow for the original string def __getitem__(self, item): if isinstance(item, tuple): item = item[0] return super().__getitem__(item) Note again that Trubar doesn't provide this code, but your application would probably use similar code. Find the complete example at Orange Canvas Core's Github .","title":"The actual code"},{"location":"questions/","text":"Questions Why Truebar? It's not Truebar but Trubar. Primo\u017e Trubar was the author of the first printed book in Slovenian language and was also the first to translated parts of the Bible into Slovene. If it's difficult to remember, imagine that the Tru- part stands for \"translation utility\", though this is only a coincidence. And Jaml comes from ...? Shouldn't I, for once, include my name in something? :) Why changing the sources? Why not calling a function, like in gettext? Because interpolation happens too early for that. Python's f-strings cannot be translated using gettext or similar tools, because gettexts translates a pattern, while f-strings are born interpolated. For instance, one could translate \"I see {n} little pigs\".format(n=7) because a string \"I see {n} little pigs\" can be passed to gettext , which returns a pattern in another language. In case of f\"I see {n} little pigs\" , the string \"I see {n} little pigs\" is never materialized. Syntactically, this is a JoinedStr , which is composed of a Constant \"I see \" , a FormattedValue (essentially n ) and another Constant . At the moment when a str object is created and could be passed to gettext , the number n is already interpolated, hence gettext would receive a string like \"I see 7 little pigs\" . Still, why not at least mark strings for translation in sources? First: why? You can either make it for translation in sources, or mark it for non-translation ( false ) in message files. Second: unless developpers are dedicated and disciplined, they will fail to mark strings, so somebody will have to mess with source later on. Third, it clutters the code. In gettext , the function that returns a translation is named _ ; this adds an underscore and parentheses (possibly within another parentheses...). In Python, _ conventionally has a special meaning, so a longer name and more \"visible\" name would be required. We prefer keeping the code clean. What if the same string appears twice in the same function/class/module, but needs different translations? Huh, find a neutral translation, or talk to developpers and ask them to split the function into two. Among 15 thousands messages in project Orange, this happenned ones and was resolvable by an (imperfect) neutral translation.","title":"Questions"},{"location":"questions/#questions","text":"","title":"Questions"},{"location":"questions/#why-truebar","text":"It's not Truebar but Trubar. Primo\u017e Trubar was the author of the first printed book in Slovenian language and was also the first to translated parts of the Bible into Slovene. If it's difficult to remember, imagine that the Tru- part stands for \"translation utility\", though this is only a coincidence.","title":"Why Truebar?"},{"location":"questions/#and-jaml-comes-from","text":"Shouldn't I, for once, include my name in something? :)","title":"And Jaml comes from ...?"},{"location":"questions/#why-changing-the-sources-why-not-calling-a-function-like-in-gettext","text":"Because interpolation happens too early for that. Python's f-strings cannot be translated using gettext or similar tools, because gettexts translates a pattern, while f-strings are born interpolated. For instance, one could translate \"I see {n} little pigs\".format(n=7) because a string \"I see {n} little pigs\" can be passed to gettext , which returns a pattern in another language. In case of f\"I see {n} little pigs\" , the string \"I see {n} little pigs\" is never materialized. Syntactically, this is a JoinedStr , which is composed of a Constant \"I see \" , a FormattedValue (essentially n ) and another Constant . At the moment when a str object is created and could be passed to gettext , the number n is already interpolated, hence gettext would receive a string like \"I see 7 little pigs\" .","title":"Why changing the sources? Why not calling a function, like in gettext?"},{"location":"questions/#still-why-not-at-least-mark-strings-for-translation-in-sources","text":"First: why? You can either make it for translation in sources, or mark it for non-translation ( false ) in message files. Second: unless developpers are dedicated and disciplined, they will fail to mark strings, so somebody will have to mess with source later on. Third, it clutters the code. In gettext , the function that returns a translation is named _ ; this adds an underscore and parentheses (possibly within another parentheses...). In Python, _ conventionally has a special meaning, so a longer name and more \"visible\" name would be required. We prefer keeping the code clean.","title":"Still, why not at least mark strings for translation in sources?"},{"location":"questions/#what-if-the-same-string-appears-twice-in-the-same-functionclassmodule-but-needs-different-translations","text":"Huh, find a neutral translation, or talk to developpers and ask them to split the function into two. Among 15 thousands messages in project Orange, this happenned ones and was resolvable by an (imperfect) neutral translation.","title":"What if the same string appears twice in the same function/class/module, but needs different translations?"},{"location":"scenarios/","text":"Common Scenarios Translations maintenance As software changes, some messages may change or be removed, and new messages may appear. To update message file, re-run the collection, specifying the same output file. This will add new messages and keep the existing translations. Any messages that are no longer needed can be recorded in a separate file by pasing an option -r . trubar collect -s code/sample -r removed.jaml sample.jaml Preparing templates Unlike in our toy example, real projects contain a large proportion of string (one half up to two thirds, in our experience) that must not be translated, such as type annotations in form of strings, various string constants and arguments, old-style named tuple declarations and so forth. Deciding whether a partiuclar string needs translation or not requires looking into code and understanding it. This presents a huge burden for translator, but can, luckily, be done once for all languages. If a project is translated into one language, we can use trubar template sample.jaml -o template.jaml to prepare a template file template.jaml for other languages. The output file will contain all strings that need attention. See details below.","title":"Common Scenarios"},{"location":"scenarios/#common-scenarios","text":"","title":"Common Scenarios"},{"location":"scenarios/#translations-maintenance","text":"As software changes, some messages may change or be removed, and new messages may appear. To update message file, re-run the collection, specifying the same output file. This will add new messages and keep the existing translations. Any messages that are no longer needed can be recorded in a separate file by pasing an option -r . trubar collect -s code/sample -r removed.jaml sample.jaml","title":"Translations maintenance"},{"location":"scenarios/#preparing-templates","text":"Unlike in our toy example, real projects contain a large proportion of string (one half up to two thirds, in our experience) that must not be translated, such as type annotations in form of strings, various string constants and arguments, old-style named tuple declarations and so forth. Deciding whether a partiuclar string needs translation or not requires looking into code and understanding it. This presents a huge burden for translator, but can, luckily, be done once for all languages. If a project is translated into one language, we can use trubar template sample.jaml -o template.jaml to prepare a template file template.jaml for other languages. The output file will contain all strings that need attention. See details below.","title":"Preparing templates"}]}